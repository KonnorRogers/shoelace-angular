{"ast":null,"code":"/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n// Any new exports need to be added to the export statement in\n// `packages/lit/src/index.all.ts`.\nimport { html as coreHtml, svg as coreSvg } from './lit-html.js';\n/**\n * Prevents JSON injection attacks.\n *\n * The goals of this brand:\n *   1) fast to check\n *   2) code is small on the wire\n *   3) multiple versions of Lit in a single page will all produce mutually\n *      interoperable StaticValues\n *   4) normal JSON.parse (without an unusual reviver) can not produce a\n *      StaticValue\n *\n * Symbols satisfy (1), (2), and (4). We use Symbol.for to satisfy (3), but\n * we don't care about the key, so we break ties via (2) and use the empty\n * string.\n */\nconst brand = Symbol.for('');\n/** Safely extracts the string part of a StaticValue. */\nconst unwrapStaticValue = value => {\n  if (value?.r !== brand) {\n    return undefined;\n  }\n  return value?.['_$litStatic$'];\n};\n/**\n * Wraps a string so that it behaves like part of the static template\n * strings instead of a dynamic value.\n *\n * Users must take care to ensure that adding the static string to the template\n * results in well-formed HTML, or else templates may break unexpectedly.\n *\n * Note that this function is unsafe to use on untrusted content, as it will be\n * directly parsed into HTML. Do not pass user input to this function\n * without sanitizing it.\n *\n * Static values can be changed, but they will cause a complete re-render\n * since they effectively create a new template.\n */\nexport const unsafeStatic = value => ({\n  ['_$litStatic$']: value,\n  r: brand\n});\nconst textFromStatic = value => {\n  if (value['_$litStatic$'] !== undefined) {\n    return value['_$litStatic$'];\n  } else {\n    throw new Error(`Value passed to 'literal' function must be a 'literal' result: ${value}. Use 'unsafeStatic' to pass non-literal values, but\n            take care to ensure page security.`);\n  }\n};\n/**\n * Tags a string literal so that it behaves like part of the static template\n * strings instead of a dynamic value.\n *\n * The only values that may be used in template expressions are other tagged\n * `literal` results or `unsafeStatic` values (note that untrusted content\n * should never be passed to `unsafeStatic`).\n *\n * Users must take care to ensure that adding the static string to the template\n * results in well-formed HTML, or else templates may break unexpectedly.\n *\n * Static values can be changed, but they will cause a complete re-render since\n * they effectively create a new template.\n */\nexport const literal = (strings, ...values) => ({\n  ['_$litStatic$']: values.reduce((acc, v, idx) => acc + textFromStatic(v) + strings[idx + 1], strings[0]),\n  r: brand\n});\nconst stringsCache = new Map();\n/**\n * Wraps a lit-html template tag (`html` or `svg`) to add static value support.\n */\nexport const withStatic = coreTag => (strings, ...values) => {\n  const l = values.length;\n  let staticValue;\n  let dynamicValue;\n  const staticStrings = [];\n  const dynamicValues = [];\n  let i = 0;\n  let hasStatics = false;\n  let s;\n  while (i < l) {\n    s = strings[i];\n    // Collect any unsafeStatic values, and their following template strings\n    // so that we treat a run of template strings and unsafe static values as\n    // a single template string.\n    while (i < l && (dynamicValue = values[i], staticValue = unwrapStaticValue(dynamicValue)) !== undefined) {\n      s += staticValue + strings[++i];\n      hasStatics = true;\n    }\n    // If the last value is static, we don't need to push it.\n    if (i !== l) {\n      dynamicValues.push(dynamicValue);\n    }\n    staticStrings.push(s);\n    i++;\n  }\n  // If the last value isn't static (which would have consumed the last\n  // string), then we need to add the last string.\n  if (i === l) {\n    staticStrings.push(strings[l]);\n  }\n  if (hasStatics) {\n    const key = staticStrings.join('$$lit$$');\n    strings = stringsCache.get(key);\n    if (strings === undefined) {\n      // Beware: in general this pattern is unsafe, and doing so may bypass\n      // lit's security checks and allow an attacker to execute arbitrary\n      // code and inject arbitrary content.\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      staticStrings.raw = staticStrings;\n      stringsCache.set(key, strings = staticStrings);\n    }\n    values = dynamicValues;\n  }\n  return coreTag(strings, ...values);\n};\n/**\n * Interprets a template literal as an HTML template that can efficiently\n * render to and update a container.\n *\n * Includes static value support from `lit-html/static.js`.\n */\nexport const html = withStatic(coreHtml);\n/**\n * Interprets a template literal as an SVG template that can efficiently\n * render to and update a container.\n *\n * Includes static value support from `lit-html/static.js`.\n */\nexport const svg = withStatic(coreSvg);","map":{"version":3,"names":["html","coreHtml","svg","coreSvg","brand","Symbol","for","unwrapStaticValue","value","r","undefined","unsafeStatic","textFromStatic","Error","literal","strings","values","reduce","acc","v","idx","stringsCache","Map","withStatic","coreTag","l","length","staticValue","dynamicValue","staticStrings","dynamicValues","i","hasStatics","s","push","key","join","get","raw","set"],"sources":["/home/KonnorRogers/shoelace-angular/node_modules/lit-html/development/static.js"],"sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n// Any new exports need to be added to the export statement in\n// `packages/lit/src/index.all.ts`.\nimport { html as coreHtml, svg as coreSvg } from './lit-html.js';\n/**\n * Prevents JSON injection attacks.\n *\n * The goals of this brand:\n *   1) fast to check\n *   2) code is small on the wire\n *   3) multiple versions of Lit in a single page will all produce mutually\n *      interoperable StaticValues\n *   4) normal JSON.parse (without an unusual reviver) can not produce a\n *      StaticValue\n *\n * Symbols satisfy (1), (2), and (4). We use Symbol.for to satisfy (3), but\n * we don't care about the key, so we break ties via (2) and use the empty\n * string.\n */\nconst brand = Symbol.for('');\n/** Safely extracts the string part of a StaticValue. */\nconst unwrapStaticValue = (value) => {\n    if (value?.r !== brand) {\n        return undefined;\n    }\n    return value?.['_$litStatic$'];\n};\n/**\n * Wraps a string so that it behaves like part of the static template\n * strings instead of a dynamic value.\n *\n * Users must take care to ensure that adding the static string to the template\n * results in well-formed HTML, or else templates may break unexpectedly.\n *\n * Note that this function is unsafe to use on untrusted content, as it will be\n * directly parsed into HTML. Do not pass user input to this function\n * without sanitizing it.\n *\n * Static values can be changed, but they will cause a complete re-render\n * since they effectively create a new template.\n */\nexport const unsafeStatic = (value) => ({\n    ['_$litStatic$']: value,\n    r: brand,\n});\nconst textFromStatic = (value) => {\n    if (value['_$litStatic$'] !== undefined) {\n        return value['_$litStatic$'];\n    }\n    else {\n        throw new Error(`Value passed to 'literal' function must be a 'literal' result: ${value}. Use 'unsafeStatic' to pass non-literal values, but\n            take care to ensure page security.`);\n    }\n};\n/**\n * Tags a string literal so that it behaves like part of the static template\n * strings instead of a dynamic value.\n *\n * The only values that may be used in template expressions are other tagged\n * `literal` results or `unsafeStatic` values (note that untrusted content\n * should never be passed to `unsafeStatic`).\n *\n * Users must take care to ensure that adding the static string to the template\n * results in well-formed HTML, or else templates may break unexpectedly.\n *\n * Static values can be changed, but they will cause a complete re-render since\n * they effectively create a new template.\n */\nexport const literal = (strings, ...values) => ({\n    ['_$litStatic$']: values.reduce((acc, v, idx) => acc + textFromStatic(v) + strings[idx + 1], strings[0]),\n    r: brand,\n});\nconst stringsCache = new Map();\n/**\n * Wraps a lit-html template tag (`html` or `svg`) to add static value support.\n */\nexport const withStatic = (coreTag) => (strings, ...values) => {\n    const l = values.length;\n    let staticValue;\n    let dynamicValue;\n    const staticStrings = [];\n    const dynamicValues = [];\n    let i = 0;\n    let hasStatics = false;\n    let s;\n    while (i < l) {\n        s = strings[i];\n        // Collect any unsafeStatic values, and their following template strings\n        // so that we treat a run of template strings and unsafe static values as\n        // a single template string.\n        while (i < l &&\n            ((dynamicValue = values[i]),\n                (staticValue = unwrapStaticValue(dynamicValue))) !== undefined) {\n            s += staticValue + strings[++i];\n            hasStatics = true;\n        }\n        // If the last value is static, we don't need to push it.\n        if (i !== l) {\n            dynamicValues.push(dynamicValue);\n        }\n        staticStrings.push(s);\n        i++;\n    }\n    // If the last value isn't static (which would have consumed the last\n    // string), then we need to add the last string.\n    if (i === l) {\n        staticStrings.push(strings[l]);\n    }\n    if (hasStatics) {\n        const key = staticStrings.join('$$lit$$');\n        strings = stringsCache.get(key);\n        if (strings === undefined) {\n            // Beware: in general this pattern is unsafe, and doing so may bypass\n            // lit's security checks and allow an attacker to execute arbitrary\n            // code and inject arbitrary content.\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            staticStrings.raw = staticStrings;\n            stringsCache.set(key, (strings = staticStrings));\n        }\n        values = dynamicValues;\n    }\n    return coreTag(strings, ...values);\n};\n/**\n * Interprets a template literal as an HTML template that can efficiently\n * render to and update a container.\n *\n * Includes static value support from `lit-html/static.js`.\n */\nexport const html = withStatic(coreHtml);\n/**\n * Interprets a template literal as an SVG template that can efficiently\n * render to and update a container.\n *\n * Includes static value support from `lit-html/static.js`.\n */\nexport const svg = withStatic(coreSvg);\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}