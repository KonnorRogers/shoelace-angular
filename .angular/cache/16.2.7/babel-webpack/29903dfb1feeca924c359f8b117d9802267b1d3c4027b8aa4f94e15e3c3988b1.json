{"ast":null,"code":"/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nimport { noChange, nothing } from '../lit-html.js';\nimport { directive, Directive, PartType } from '../directive.js';\nimport { isSingleExpression, setCommittedValue } from '../directive-helpers.js';\nclass LiveDirective extends Directive {\n  constructor(partInfo) {\n    super(partInfo);\n    if (!(partInfo.type === PartType.PROPERTY || partInfo.type === PartType.ATTRIBUTE || partInfo.type === PartType.BOOLEAN_ATTRIBUTE)) {\n      throw new Error('The `live` directive is not allowed on child or event bindings');\n    }\n    if (!isSingleExpression(partInfo)) {\n      throw new Error('`live` bindings can only contain a single expression');\n    }\n  }\n  render(value) {\n    return value;\n  }\n  update(part, [value]) {\n    if (value === noChange || value === nothing) {\n      return value;\n    }\n    const element = part.element;\n    const name = part.name;\n    if (part.type === PartType.PROPERTY) {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      if (value === element[name]) {\n        return noChange;\n      }\n    } else if (part.type === PartType.BOOLEAN_ATTRIBUTE) {\n      if (!!value === element.hasAttribute(name)) {\n        return noChange;\n      }\n    } else if (part.type === PartType.ATTRIBUTE) {\n      if (element.getAttribute(name) === String(value)) {\n        return noChange;\n      }\n    }\n    // Resets the part's value, causing its dirty-check to fail so that it\n    // always sets the value.\n    setCommittedValue(part);\n    return value;\n  }\n}\n/**\n * Checks binding values against live DOM values, instead of previously bound\n * values, when determining whether to update the value.\n *\n * This is useful for cases where the DOM value may change from outside of\n * lit-html, such as with a binding to an `<input>` element's `value` property,\n * a content editable elements text, or to a custom element that changes it's\n * own properties or attributes.\n *\n * In these cases if the DOM value changes, but the value set through lit-html\n * bindings hasn't, lit-html won't know to update the DOM value and will leave\n * it alone. If this is not what you want--if you want to overwrite the DOM\n * value with the bound value no matter what--use the `live()` directive:\n *\n * ```js\n * html`<input .value=${live(x)}>`\n * ```\n *\n * `live()` performs a strict equality check against the live DOM value, and if\n * the new value is equal to the live value, does nothing. This means that\n * `live()` should not be used when the binding will cause a type conversion. If\n * you use `live()` with an attribute binding, make sure that only strings are\n * passed in, or the binding will update every render.\n */\nexport const live = directive(LiveDirective);","map":{"version":3,"names":["noChange","nothing","directive","Directive","PartType","isSingleExpression","setCommittedValue","LiveDirective","constructor","partInfo","type","PROPERTY","ATTRIBUTE","BOOLEAN_ATTRIBUTE","Error","render","value","update","part","element","name","hasAttribute","getAttribute","String","live"],"sources":["/home/KonnorRogers/shoelace-angular/node_modules/lit-html/development/directives/live.js"],"sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nimport { noChange, nothing } from '../lit-html.js';\nimport { directive, Directive, PartType, } from '../directive.js';\nimport { isSingleExpression, setCommittedValue } from '../directive-helpers.js';\nclass LiveDirective extends Directive {\n    constructor(partInfo) {\n        super(partInfo);\n        if (!(partInfo.type === PartType.PROPERTY ||\n            partInfo.type === PartType.ATTRIBUTE ||\n            partInfo.type === PartType.BOOLEAN_ATTRIBUTE)) {\n            throw new Error('The `live` directive is not allowed on child or event bindings');\n        }\n        if (!isSingleExpression(partInfo)) {\n            throw new Error('`live` bindings can only contain a single expression');\n        }\n    }\n    render(value) {\n        return value;\n    }\n    update(part, [value]) {\n        if (value === noChange || value === nothing) {\n            return value;\n        }\n        const element = part.element;\n        const name = part.name;\n        if (part.type === PartType.PROPERTY) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            if (value === element[name]) {\n                return noChange;\n            }\n        }\n        else if (part.type === PartType.BOOLEAN_ATTRIBUTE) {\n            if (!!value === element.hasAttribute(name)) {\n                return noChange;\n            }\n        }\n        else if (part.type === PartType.ATTRIBUTE) {\n            if (element.getAttribute(name) === String(value)) {\n                return noChange;\n            }\n        }\n        // Resets the part's value, causing its dirty-check to fail so that it\n        // always sets the value.\n        setCommittedValue(part);\n        return value;\n    }\n}\n/**\n * Checks binding values against live DOM values, instead of previously bound\n * values, when determining whether to update the value.\n *\n * This is useful for cases where the DOM value may change from outside of\n * lit-html, such as with a binding to an `<input>` element's `value` property,\n * a content editable elements text, or to a custom element that changes it's\n * own properties or attributes.\n *\n * In these cases if the DOM value changes, but the value set through lit-html\n * bindings hasn't, lit-html won't know to update the DOM value and will leave\n * it alone. If this is not what you want--if you want to overwrite the DOM\n * value with the bound value no matter what--use the `live()` directive:\n *\n * ```js\n * html`<input .value=${live(x)}>`\n * ```\n *\n * `live()` performs a strict equality check against the live DOM value, and if\n * the new value is equal to the live value, does nothing. This means that\n * `live()` should not be used when the binding will cause a type conversion. If\n * you use `live()` with an attribute binding, make sure that only strings are\n * passed in, or the binding will update every render.\n */\nexport const live = directive(LiveDirective);\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA,SAASA,QAAQ,EAAEC,OAAO,QAAQ,gBAAgB;AAClD,SAASC,SAAS,EAAEC,SAAS,EAAEC,QAAQ,QAAS,iBAAiB;AACjE,SAASC,kBAAkB,EAAEC,iBAAiB,QAAQ,yBAAyB;AAC/E,MAAMC,aAAa,SAASJ,SAAS,CAAC;EAClCK,WAAWA,CAACC,QAAQ,EAAE;IAClB,KAAK,CAACA,QAAQ,CAAC;IACf,IAAI,EAAEA,QAAQ,CAACC,IAAI,KAAKN,QAAQ,CAACO,QAAQ,IACrCF,QAAQ,CAACC,IAAI,KAAKN,QAAQ,CAACQ,SAAS,IACpCH,QAAQ,CAACC,IAAI,KAAKN,QAAQ,CAACS,iBAAiB,CAAC,EAAE;MAC/C,MAAM,IAAIC,KAAK,CAAC,gEAAgE,CAAC;IACrF;IACA,IAAI,CAACT,kBAAkB,CAACI,QAAQ,CAAC,EAAE;MAC/B,MAAM,IAAIK,KAAK,CAAC,sDAAsD,CAAC;IAC3E;EACJ;EACAC,MAAMA,CAACC,KAAK,EAAE;IACV,OAAOA,KAAK;EAChB;EACAC,MAAMA,CAACC,IAAI,EAAE,CAACF,KAAK,CAAC,EAAE;IAClB,IAAIA,KAAK,KAAKhB,QAAQ,IAAIgB,KAAK,KAAKf,OAAO,EAAE;MACzC,OAAOe,KAAK;IAChB;IACA,MAAMG,OAAO,GAAGD,IAAI,CAACC,OAAO;IAC5B,MAAMC,IAAI,GAAGF,IAAI,CAACE,IAAI;IACtB,IAAIF,IAAI,CAACR,IAAI,KAAKN,QAAQ,CAACO,QAAQ,EAAE;MACjC;MACA,IAAIK,KAAK,KAAKG,OAAO,CAACC,IAAI,CAAC,EAAE;QACzB,OAAOpB,QAAQ;MACnB;IACJ,CAAC,MACI,IAAIkB,IAAI,CAACR,IAAI,KAAKN,QAAQ,CAACS,iBAAiB,EAAE;MAC/C,IAAI,CAAC,CAACG,KAAK,KAAKG,OAAO,CAACE,YAAY,CAACD,IAAI,CAAC,EAAE;QACxC,OAAOpB,QAAQ;MACnB;IACJ,CAAC,MACI,IAAIkB,IAAI,CAACR,IAAI,KAAKN,QAAQ,CAACQ,SAAS,EAAE;MACvC,IAAIO,OAAO,CAACG,YAAY,CAACF,IAAI,CAAC,KAAKG,MAAM,CAACP,KAAK,CAAC,EAAE;QAC9C,OAAOhB,QAAQ;MACnB;IACJ;IACA;IACA;IACAM,iBAAiB,CAACY,IAAI,CAAC;IACvB,OAAOF,KAAK;EAChB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMQ,IAAI,GAAGtB,SAAS,CAACK,aAAa,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}